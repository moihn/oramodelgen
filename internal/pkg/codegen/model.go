package codegen

import (
	"sort"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/moihn/oramodelgen/internal/pkg/config"
	"github.com/moihn/oramodelgen/internal/pkg/dbmodel"
	"github.com/sirupsen/logrus"
)

type CodegenColumnModel struct {
	ColumnName          string
	ColumnLowerName     string
	ColumnFieldName     string
	ColumnVariableName  string
	ColumnIsPrimaryKey  bool
	ColumnAutoGenerated bool
	// ColumnType          string
	ColumnGoType string
}

type CodegenConstraintModel struct {
	ConstraintName       string
	ConstraintLowerName  string
	ConstraintIndex      *CodegenIndexModel
	ConstraintMethodName string
	ConstraintColumns    []*CodegenColumnModel
}

type CodegenIndexModel struct {
	IndexName       string
	IndexLowerName  string
	IndexMethodName string
	IndexColumns    []*CodegenColumnModel
	IndexUnique     bool
}

type CodegenOrderByModel struct {
	ByColumn   *CodegenColumnModel
	Descending bool
}

type CodegenTablePopulateModel struct {
	PopulateMethodName string
	PopulateByColumns  []*CodegenColumnModel
	OrderByColumns     []*CodegenOrderByModel
}

type CodegenTableModel struct {
	Package             string
	TableName           string
	TableLowerName      string
	TableStructName     string
	TableObjectName     string
	TableColumnList     []*CodegenColumnModel
	TableIndexList      []*CodegenIndexModel
	TableConstraintList []*CodegenConstraintModel
	TablePopulateList   []*CodegenTablePopulateModel
}

type CodegenQueryParameter struct {
	VariableName string
	GoType       string
}

type CodegenQueryModel struct {
	Package            string
	QueryName          string
	QueryMethodName    string
	QueryStructName    string
	QueryObjectName    string
	QueryString        string
	QueryColumnList    []*CodegenColumnModel
	QueryParameterList []*CodegenQueryParameter
}

func resolveGoDataType(column *dbmodel.DbColumnModel) string {
	switch {
	case column.Type == dbmodel.Blob_t || column.Type == dbmodel.Char_t || column.Type == dbmodel.Clob_t || column.Type == dbmodel.Varchar_t:
		return "string"
	case column.Type == dbmodel.Date_t:
		return "time.Time"
	case column.Type == dbmodel.Long_t:
		return "int64"
	case column.Type == dbmodel.Float_t:
		return "float32"
	default:
		return "string"
	}
}

func resolveGoDataTypeFromDbDataType(datatype string) string {
	switch strings.ToUpper(datatype) {
	case "STRING":
		return "string"
	case "DATE":
		return "time.Time"
	case "INT":
		return "int64"
	case "FLOAT":
		return "float32"
	default:
		return "string"
	}
}

func FromDbTableModel(tableModel dbmodel.DbTableModel, tableDef config.TableDef) CodegenTableModel {
	codegenModel := CodegenTableModel{
		TableName:      tableModel.Name,
		TableLowerName: strings.ToLower(tableModel.Name),
	}
	codegenModel.TableStructName = strcase.ToCamel(codegenModel.TableLowerName)
	codegenModel.TableObjectName = strcase.ToLowerCamel(codegenModel.TableLowerName)
	columnMap := map[string]*CodegenColumnModel{}
	for _, dbCol := range tableModel.Columns {
		codegenCol := &CodegenColumnModel{
			ColumnName:          dbCol.Name,
			ColumnLowerName:     strings.ToLower(dbCol.Name),
			ColumnIsPrimaryKey:  dbCol.IsPrimaryKey,
			ColumnAutoGenerated: dbCol.AutoGenerated,
			// ColumnType:          dbCol.Type,
			ColumnGoType: resolveGoDataType(dbCol),
		}
		codegenCol.ColumnFieldName = strcase.ToCamel(codegenCol.ColumnLowerName)
		codegenCol.ColumnVariableName = strcase.ToLowerCamel(codegenCol.ColumnLowerName)
		codegenModel.TableColumnList = append(codegenModel.TableColumnList, codegenCol)
		columnMap[codegenCol.ColumnName] = codegenCol
	}

	indexMap := map[string]*CodegenIndexModel{}
	for _, dbIndex := range tableModel.Indexes {
		if dbIndex.Unique { // we only need to care about unique index for generating GetBy method for now
			codegenIndex := &CodegenIndexModel{
				IndexName:      dbIndex.Name,
				IndexLowerName: strings.ToLower(dbIndex.Name),
				IndexUnique:    dbIndex.Unique,
			}
			codegenIndex.IndexMethodName = "GetBy"
			for _, dbIndexCol := range dbIndex.Columns {
				codegenIndex.IndexColumns = append(codegenIndex.IndexColumns, columnMap[dbIndexCol.Name])
				codegenIndex.IndexMethodName += strcase.ToCamel(dbIndexCol.Name)
			}
			codegenModel.TableIndexList = append(codegenModel.TableIndexList, codegenIndex)
			indexMap[codegenIndex.IndexName] = codegenIndex
		}
	}

	for _, dbConstraint := range tableModel.Constraints {
		if dbConstraint.ReferencedTable != nil { // we only need to care about FK to generate likely to be used PopulateBy method for now
			codegenConstraint := &CodegenConstraintModel{
				ConstraintName:      dbConstraint.Name,
				ConstraintLowerName: strings.ToLower(dbConstraint.Name),
				ConstraintIndex:     indexMap[dbConstraint.Index.Name],
			}
			codegenConstraint.ConstraintMethodName = "PopulateBy"
			for _, dbConstraintCol := range dbConstraint.Columns {
				codegenConstraint.ConstraintColumns = append(codegenConstraint.ConstraintColumns, columnMap[dbConstraintCol.Name])
				codegenConstraint.ConstraintMethodName += strcase.ToCamel(dbConstraintCol.Name)
			}
			codegenModel.TableConstraintList = append(codegenModel.TableConstraintList, codegenConstraint)
		}
	}

	populateMaps := map[string]*CodegenTablePopulateModel{}
	for _, populateDef := range tableDef.Populate {
		sort.Strings(populateDef.By)
		populateModel := CodegenTablePopulateModel{}
		name := "PopulateBy"
		// columns
		for _, byCol := range populateDef.By {
			colName := strings.ToUpper(byCol)
			if colModel, exists := columnMap[colName]; !exists {
				logrus.Fatalf("no column named %v in table %v", colName, tableModel.Name)
			} else {
				name += strcase.ToCamel(strings.ToLower(byCol))
				populateModel.PopulateByColumns = append(populateModel.PopulateByColumns, colModel)
			}
		}

		// order by
		if len(populateDef.Orderby) > 0 {
			name += "OrderBy"
		}
		for _, orderCol := range populateDef.Orderby {
			orderColName := strings.ToUpper(orderCol.Column)
			if colModel, exists := columnMap[orderColName]; !exists {
				logrus.Fatalf("no column named %v in table %v", orderColName, tableModel.Name)
			} else {
				name += strcase.ToCamel(strings.ToLower(orderCol.Column))
				if orderCol.Descending {
					name += "Desc"
				} else {
					name += "Asc"
				}
				populateModel.OrderByColumns = append(populateModel.OrderByColumns, &CodegenOrderByModel{
					ByColumn:   colModel,
					Descending: orderCol.Descending,
				})
			}
		}
		if _, exists := populateMaps[name]; exists {
			logrus.Fatalf("duplicate populate is found for %v: %#v", tableModel.Name, populateDef)
		} else {
			populateModel.PopulateMethodName = name
			codegenModel.TablePopulateList = append(codegenModel.TablePopulateList, &populateModel)
			populateMaps[name] = &populateModel
		}
	}
	return codegenModel
}

func FromDbQueryModel(queryModel dbmodel.DbQueryModel, queryDef config.QueryDef) CodegenQueryModel {
	codegenModel := CodegenQueryModel{
		QueryName:       queryDef.Name,
		QueryMethodName: strcase.ToCamel(queryDef.Name),
		QueryStructName: strcase.ToCamel(queryDef.Name),
		QueryObjectName: strcase.ToLowerCamel(queryDef.Name),
		QueryString:     queryDef.Query,
	}

	for _, dbColModel := range queryModel.Columns {
		colNameLower := strings.ToLower(dbColModel.Name)
		codegenModel.QueryColumnList = append(codegenModel.QueryColumnList, &CodegenColumnModel{
			ColumnName:          dbColModel.Name,
			ColumnLowerName:     colNameLower,
			ColumnFieldName:     strcase.ToCamel(colNameLower),
			ColumnVariableName:  strcase.ToLowerCamel(colNameLower),
			ColumnIsPrimaryKey:  false,
			ColumnAutoGenerated: false,
			ColumnGoType:        resolveGoDataType(dbColModel),
		})
	}

	for _, param := range queryDef.Parameters {
		codegenModel.QueryParameterList = append(codegenModel.QueryParameterList, &CodegenQueryParameter{
			VariableName: param.Name,
			GoType:       resolveGoDataTypeFromDbDataType(param.Type),
		})
	}

	return codegenModel
}
