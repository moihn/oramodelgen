package {{.Package}}

import "database/sql"

type {{.TableStructName}} struct {
    {{- range .TableColumnList}}
    {{.ColumnFieldName}}  {{.ColumnGoType}}
    {{- end}}
}

func (row *{{.TableStructName}}) Insert(tx *sql.Tx) error {
    sqlQuery := `
        insert into {{$.TableName}}
        (
            {{$count := 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{if not .ColumnAutoGenerated}}{{.ColumnName}}{{$count = incr $count}}{{end}}
            {{- end}}
        )
        values
        (
            {{$count = 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{if not .ColumnAutoGenerated}}:{{.ColumnVariableName}}{{$count = incr $count}}{{end}}
            {{- end}}
        )
        {{- $count = 0}}
        {{- range $.TableColumnList}}{{if .ColumnAutoGenerated}}{{if not $count}}
        returning
        {{else}},
        {{end}}    {{.ColumnName}}{{$count = incr $count}}{{end}}
        {{- end}}
        {{- $count = 0}}
        {{- range $.TableColumnList}}{{if .ColumnAutoGenerated}}{{if not $count}}
        to
        {{else}},
        {{end}}    :{{.ColumnVariableName}}{{$count = incr $count}}{{end}}
        {{- end}}
    `
    if result, err := tx.Exec(sqlQuery,
        {{- range $.TableColumnList}}{{if not .ColumnAutoGenerated}}
        sql.Named("{{.ColumnVariableName}}", row.{{.ColumnFieldName}}),{{end}}
        {{- end}}
        {{- range $.TableColumnList}}{{if .ColumnAutoGenerated}}
        sql.Named("{{.ColumnVariableName}}", sql.Out{Dest: &row.{{.ColumnFieldName}}}),{{end}}
        {{- end }}
        ); err != nil {
        return fmt.Errorf("failed to execute insert query [%v]: %v", sqlQuery, err)
    } else {
        nRows, err := result.RowsAffected()
        if err != nil {
                return err
        }
        if nRows == 0 {
                fmt.Errorf("failed to insert {{$.TableName}} row [%v]: %#v", sqlQuery, row)
        }
    }
    return nil
}

func (row *{{.TableStructName}}) Update(tx *sql.Tx) error {
    sqlQuery := `
        update {{$.TableName}}
        set
            {{$count := 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{if not .ColumnIsPrimaryKey}}{{.ColumnName}} = :{{.ColumnVariableName}}{{$count = incr $count}}{{end}}
            {{- end}}
        where 1 = 1
            {{- range $.TableColumnList}}{{if .ColumnIsPrimaryKey}}
            and {{.ColumnName}} = :{{.ColumnVariableName}}{{end}}
            {{- end}}
    `
    if result, err := tx.Exec(sqlQuery,
        {{- range $.TableColumnList}}{{if not .ColumnIsPrimaryKey}}
        sql.Named("{{.ColumnVariableName}}", row.{{.ColumnFieldName}}),{{end}}
        {{- end}}
        {{- range $.TableColumnList}}{{if .ColumnIsPrimaryKey}}
        sql.Named("{{.ColumnVariableName}}", row.{{.ColumnFieldName}}),{{end}}
        {{- end}}
    ); err != nnil {
        return fmt.Errorf("failed to execute update query [%v]: %v", sqlQuery, err)
    } else {
        nRows, err := result.RowsAffected()
        if err != nil {
            return err
        }
        if nRows == 0 {
            return fmt.Errorf("failed to update {{$.TableName}} row [%v]: %#v", sqlQuery, row)
        }
    }
    return nil
}

{{range .TableIndexList}}
func {{$.TableStructName}}{{.IndexMethodName}}(
    tx *sql.Tx,
    {{- range .IndexColumns}}
    {{.ColumnVariableName}} {{.ColumnGoType}},
    {{- end}}
) ({{if .IndexUnique}}{{else}}[]{{end}}*{{$.TableStructName}}, error) {
    sqlQuery := `
        select
            {{$count := 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{.ColumnName}}{{$count = incr $count}}
            {{- end}}
        from {{$.TableName}}
        where 1 = 1
          {{- range .IndexColumns}}
          and {{.ColumnName}}  = :{{.ColumnVariableName}}
          {{- end}}
    `
    rows, err := tx.Query(sqlQuery,
        {{- range .IndexColumns}}
        sql.Named("{{.ColumnVariableName}}", {{.ColumnVariableName}}),
        {{- end}}
    )
    if err != nil {
        return nil, err
    }
    {{- if .IndexUnique}}
    if rows.Next() {
        row := {{$.TableStructName}}{}
        if err := rows.Scan(
            {{- range $.TableColumnList}}
            &row.{{.ColumnFieldName}},
            {{- end}}
        ); err != nil {
            return nil, err
        }
        return &row, nil
    }
    return nil, nil
    {{- else}}
    results := []*{{$.TableStructName}}{}
    for rows.Next() {
        row := {{$.TableStructName}}{}
        if err := rows.Scan(
            {{- range $.TableColumnList}}
            &row.{{.ColumnFieldName}},
            {{- end}}
        ); err != nil {
            return nil, err
        }
        results = append(results, &row)
    }
    return results, nil
    {{- end}}
}
{{end}}

{{range .TableConstraintList -}}
func {{$.TableStructName}}{{.ConstraintMethodName}}(
    tx *sql.Tx,
    {{- range .ConstraintColumns}}
    {{.ColumnVariableName}} {{.ColumnGoType}},
    {{- end}}
) (*{{$.TableStructName}}, error) {
    sqlQuery := `
        select
            {{$count := 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{.ColumnName}}{{$count = incr $count}}
            {{- end}}
        from {{$.TableName}}
        where 1 = 1
          {{- range .ConstraintColumns}}
          and {{.ColumnName}}  = :{{.ColumnVariableName}}
          {{- end}}
    `
    rows, err := tx.Query(sqlQuery,
        {{- range .ConstraintColumns}}
        sql.Named("{{.ColumnVariableName}}", {{.ColumnVariableName}}),
        {{- end}}
    )
    if err != nil {
        return nil, err
    }
    if rows.Next() {
        result := {{$.TableStructName}}{}
        if err := rows.Scan(
            {{- range $.TableColumnList}}
            &result.{{.ColumnFieldName}},
            {{- end}}
        ); err != nil {
            return nil, err
        }
        return &result, nil
    }
    return nil, nil
}
{{- end}}
