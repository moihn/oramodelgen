package {{.Package}}

import (
    "database/sql"
    "fmt"
    {{- range .Imports}}
    "{{.}}"
    {{- end}}
)

type {{.TableRowStructName}} struct {
    {{- range .TableColumnList}}
    {{.ColumnFieldName}}  {{.ColumnGoType}}
    {{- end}}
}

func (row *{{.TableRowStructName}}) Insert(tx *sql.Tx) error {
    sqlQuery := `
        insert into {{$.TableName}}
        (
            {{$count := 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{if not .ColumnAutoGenerated}}{{.ColumnName}}{{$count = incr $count}}{{end}}
            {{- end}}
        )
        values
        (
            {{$count = 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{if not .ColumnAutoGenerated}}:{{.ColumnVariableName}}{{$count = incr $count}}{{end}}
            {{- end}}
        )
        {{- $count = 0}}
        {{- range $.TableColumnList}}{{if .ColumnAutoGenerated}}{{if not $count}}
        returning
        {{else}},
        {{end}}    {{.ColumnName}}{{$count = incr $count}}{{end}}
        {{- end}}
        {{- $count = 0}}
        {{- range $.TableColumnList}}{{if .ColumnAutoGenerated}}{{if not $count}}
        to
        {{else}},
        {{end}}    :{{.ColumnVariableName}}{{$count = incr $count}}{{end}}
        {{- end}}
    `
    if result, err := tx.Exec(sqlQuery,
        {{- range $.TableColumnList}}{{if not .ColumnAutoGenerated}}
        sql.Named("{{.ColumnVariableName}}", row.{{.ColumnFieldName}}),{{end}}
        {{- end}}
        {{- range $.TableColumnList}}{{if .ColumnAutoGenerated}}
        sql.Named("{{.ColumnVariableName}}", sql.Out{Dest: &row.{{.ColumnFieldName}}}),{{end}}
        {{- end }}
        ); err != nil {
        return fmt.Errorf("failed to execute insert query [%v]: %v", sqlQuery, err)
    } else {
        nRows, err := result.RowsAffected()
        if err != nil {
                return err
        }
        if nRows == 0 {
                return fmt.Errorf("failed to insert {{$.TableName}} row [%v]: %#v", sqlQuery, row)
        }
    }
    return nil
}

func (row *{{.TableRowStructName}}) Update(tx *sql.Tx) error {
    sqlQuery := `
        update {{$.TableName}}
        set
            {{$count := 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{if not .ColumnIsPrimaryKey}}{{.ColumnName}} = :{{.ColumnVariableName}}{{$count = incr $count}}{{end}}
            {{- end}}
        where 1 = 1
            {{- range $.TableColumnList}}{{if .ColumnIsPrimaryKey}}
            and {{.ColumnName}} = :{{.ColumnVariableName}}{{end}}
            {{- end}}
    `
    if result, err := tx.Exec(sqlQuery,
        {{- range $.TableColumnList}}{{if not .ColumnIsPrimaryKey}}
        sql.Named("{{.ColumnVariableName}}", row.{{.ColumnFieldName}}),{{end}}
        {{- end}}
        {{- range $.TableColumnList}}{{if .ColumnIsPrimaryKey}}
        sql.Named("{{.ColumnVariableName}}", row.{{.ColumnFieldName}}),{{end}}
        {{- end}}
    ); err != nil {
        return fmt.Errorf("failed to execute update query [%v]: %v", sqlQuery, err)
    } else {
        nRows, err := result.RowsAffected()
        if err != nil {
            return err
        }
        if nRows == 0 {
            return fmt.Errorf("failed to update {{$.TableName}} row [%v]: %#v", sqlQuery, row)
        }
    }
    return nil
}

{{- range .TableIndexList}}

func {{$.TableCamelName}}{{.IndexMethodName}}(
    tx *sql.Tx,
    {{- range .IndexColumns}}
    {{.ColumnVariableName}} {{.ColumnGoType}},
    {{- end}}
) ({{if .IndexUnique}}{{else}}[]{{end}}*{{$.TableRowStructName}}, error) {
    sqlQuery := `
        select
            {{$count := 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{.ColumnName}}{{$count = incr $count}}
            {{- end}}
        from {{$.TableName}}
        where 1 = 1
          {{- range .IndexColumns}}
          and {{.ColumnName}}  = :{{.ColumnVariableName}}
          {{- end}}
    `
    rows, err := tx.Query(sqlQuery,
        {{- range .IndexColumns}}
        sql.Named("{{.ColumnVariableName}}", {{.ColumnVariableName}}),
        {{- end}}
    )
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    {{- if .IndexUnique}}
    if rows.Next() {
        row := {{$.TableRowStructName}}{}
        if err := rows.Scan(
            {{- range $.TableColumnList}}
            &row.{{.ColumnFieldName}},
            {{- end}}
        ); err != nil {
            return nil, err
        }
        return &row, nil
    }
    return nil, nil
    {{- else}}
    results := []*{{$.TableRowStructName}}{}
    for rows.Next() {
        row := {{$.TableRowStructName}}{}
        if err := rows.Scan(
            {{- range $.TableColumnList}}
            &row.{{.ColumnFieldName}},
            {{- end}}
        ); err != nil {
            return nil, err
        }
        results = append(results, &row)
    }
    return results, nil
    {{- end}}
}
{{end}}

{{- range .TableConstraintList}}

func {{$.TableCamelName}}{{.ConstraintMethodName}}(
    tx *sql.Tx,
    {{- range .ConstraintColumns}}
    {{.ColumnVariableName}} {{.ColumnGoType}},
    {{- end}}
) ([]*{{$.TableRowStructName}}, error) {
    sqlQuery := `
        select
            {{$count := 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{.ColumnName}}{{$count = incr $count}}
            {{- end}}
        from {{$.TableName}}
        where 1 = 1
          {{- range .ConstraintColumns}}
          and {{.ColumnName}}  = :{{.ColumnVariableName}}
          {{- end}}
    `
    rows, err := tx.Query(sqlQuery,
        {{- range .ConstraintColumns}}
        sql.Named("{{.ColumnVariableName}}", {{.ColumnVariableName}}),
        {{- end}}
    )
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    result := []*{{$.TableRowStructName}}{}
    for rows.Next() {
        row := {{$.TableRowStructName}}{}
        if err := rows.Scan(
            {{- range $.TableColumnList}}
            &row.{{.ColumnFieldName}},
            {{- end}}
        ); err != nil {
            return nil, err
        }
        result = append(result, &row)
    }
    return result, nil
}
{{- end}}

{{- range .TablePopulateList}}

func {{$.TableCamelName}}{{.PopulateMethodName}}(
    tx *sql.Tx,
    {{- range .PopulateByColumns}}
    {{.ColumnVariableName}} {{.ColumnGoType}},
    {{- end}}
) ([]*{{$.TableRowStructName}}, error) {
    sqlQuery := `
        select
            {{$count := 0}}
            {{- range $.TableColumnList}}{{if $count}},
            {{end}}{{.ColumnName}}{{$count = incr $count}}
            {{- end}}
        from {{$.TableName}}
        where 1 = 1
          {{- range .PopulateByColumns}}
          and {{.ColumnName}}  = :{{.ColumnVariableName}}
          {{- end}}
        {{- $count = 0}}
        {{- range .OrderByColumns}}{{if $count}},
        {{else}}
        order by{{end}}
        {{- with .ByColumn}}
          {{.ColumnName}}
        {{- end}} {{if .Descending}}DESC{{else}}ASC{{end}}{{$count = incr $count}}
        {{- end}}
    `
    rows, err := tx.Query(sqlQuery,
        {{- range .PopulateByColumns}}
        sql.Named("{{.ColumnVariableName}}", {{.ColumnVariableName}}),
        {{- end}}
    )
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    result := []*{{$.TableRowStructName}}{}
    for rows.Next() {
        row := {{$.TableRowStructName}}{}
        if err := rows.Scan(
            {{- range $.TableColumnList}}
            &row.{{.ColumnFieldName}},
            {{- end}}
        ); err != nil {
            return nil, err
        }
        result = append(result, &row)
    }
    return result, nil
}
{{- end}}
